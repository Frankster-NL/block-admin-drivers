{
  "name": "hyperspace",
  "version": "0.1.1",
  "description": "render streams of html on the client and the server",
  "main": "index.js",
  "browser": "browser.js",
  "dependencies": {
    "domify": "~0.2.0",
    "hyperglue": "~1.1.0",
    "through": "~2.3.4"
  },
  "devDependencies": {
    "shoe": "~0.0.11",
    "hyperstream": "~0.2.0",
    "brfs": "~0.0.5",
    "slice-file": "~0.2.0"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/substack/hyperspace.git"
  },
  "homepage": "https://github.com/substack/hyperspace",
  "keywords": [
    "html",
    "browser",
    "server",
    "render",
    "seo",
    "indexable",
    "realtime",
    "template"
  ],
  "author": {
    "name": "James Halliday",
    "email": "mail@substack.net",
    "url": "http://substack.net"
  },
  "license": "MIT",
  "readme": "# hyperspace\n\nrender streams of html on the client and the server\n\nUse the same rendering logic in the browser and the server to build\nSEO-friendly pages with indexable realtime updates.\n\nThis module is just an encapsulation of\n[the streaming html example](https://github.com/substack/stream-handbook#html-streams-for-the-browser-and-the-server)\nfrom the stream handbook that uses\n[hyperglue](https://github.com/substack/hyperglue) and json internally instead\nof externally.\n\n# example\n\n## simple\n\nFirst pick a stream data source that will give you records and let you subscribe\nto a changes feed. In this example we'll use\n[slice-file](https://github.com/substack/slice-file) to read from a single text\nfile to simplify the example code.\n\nLet's start with the rendering logic that will be used on both the client and\nthe server:\n\nrender.js:\n\n``` js\nvar hyperspace = require('hyperspace');\nvar fs = require('fs');\nvar html = fs.readFileSync(__dirname + '/static/row.html');\n\nmodule.exports = function () {\n    return hyperspace(html, function (row) {\n        return {\n            '.who': row.who,\n            '.message': row.message\n        };\n    });\n};\n```\n\nThe return value of `hyperspace()` is a stream that takes lines of json as input\nand returns html strings as its output. Text, the universal interface!\n\nWe're doing `fs.readFileSync()` in this shared rendering code but we can use\n[brfs](http://github.com/substack/brfs) to make this work for the browser using\n[browserify](http://browserify.org). The callback to `hyperspace()` merely\ntakes `row` objects and returns\n[hyperglue](https://github.com/substack/hyperglue) mapping of css selectors to\ncontent and attributes. Here we're updating the `\"who\"` and `\"message\"` divs\nfrom the `row.html` which looks like:\n\nrow.html:\n\n``` html\n<div class=\"row\">\n  <div class=\"who\"></div>\n  <div class=\"message\"></div>\n</div>\n```\n\nThe browser code to render this is super simple. We can just `require()` the\nshared `render.js` file and hook that into a stream. In this example we'll use\n[shoe](http://github.com/substack/shoe) to open a simple streaming websocket\nconnection with fallbacks:\n\nbrowser.js:\n\n``` js\nvar shoe = require('shoe');\nvar render = require('./render');\n\nshoe('/sock').pipe(render().appendTo('#rows'));\n```\n\nIf you need to do something with each rendered row you can just listen for\n`'element'` events from the `render()` object to get each element from the\ndataset, including the elements that were rendered server-side.\n\nNow our server will need to serve up 2 parts of our data stream: the initial\ncontent list and the stream of realtime updates. We'll use\n[hyperstream](https://github.com/substack/hyperstream) to pipe content rendered\nwith our `render.js` from before into the `#rows` div of our `index.html` file.\nThen we'll use [shoe](http://github.com/substack/shoe) to pipe the rest of the\ncontent to the browser where it can be rendered client-side.\n\nserver.js:\n\n``` js\nvar http = require('http');\nvar fs = require('fs');\nvar hyperstream = require('hyperstream');\nvar ecstatic = require('ecstatic')(__dirname + '/static');\n\nvar sliceFile = require('slice-file');\nvar sf = sliceFile(__dirname + '/data.txt');\n\nvar render = require('./render');\n\nvar server = http.createServer(function (req, res) {\n    if (req.url === '/') {\n        var hs = hyperstream({ '#rows': sf.slice(-5).pipe(render()) });\n        var rs = fs.createReadStream(__dirname + '/static/index.html');\n        rs.pipe(hs).pipe(res);\n    }\n    else ecstatic(req, res)\n});\nserver.listen(8000);\n\nvar shoe = require('shoe');\nvar sock = shoe(function (stream) {\n    sf.follow(-1,0).pipe(stream);\n});\nsock.install(server, '/sock');\n```\n\nAnd our `index.html` file is just:\n\nindex.html\n\n``` html\n<html>\n  <head>\n    <link rel=\"stylesheet\" href=\"/style.css\">\n  </head>\n  <body>\n    <h1>rows</h1>\n    <div id=\"rows\"></div>\n    <script src=\"/bundle.js\"></script>\n  </body>\n</html>\n```\n\nNow just compile with [browserify](http://browserify.org) and\n[brfs](http://github.com/substack/brfs):\n\n```\n$ browserify -t brfs browser.js > static/bundle.js\n```\n\nNow we can populate `data.txt` with some silly data:\n\n```\n$ echo '{\"who\":\"substack\",\"message\":\"beep boop.\"}' >> data.txt\n$ echo '{\"who\":\"zoltar\",\"message\":\"COWER PUNY HUMANS\"}' >> data.txt\n```\n\nthen spin up the server:\n\n```\n$ node server.js\n```\n\nthen navigate to `localhost:8000` where we will see our content. If we add some\nmore content:\n\n```\n$ echo '{\"who\":\"substack\",\"message\":\"oh hello.\"}' >> data.txt\n$ echo '{\"who\":\"zoltar\",\"message\":\"HEAR ME!\"}' >> data.txt\n```\n\nthen the page updates automatically with the realtime updates, hooray!\n\nWe're now using exactly the same rendering logic on both the client and the\nserver to serve up SEO-friendly, indexable realtime content.\n\n## requesting more data\n\nWe can extend the previous example with a \"more\" button to load more content on\ndemand using the existing streams and rendering logic already in place.\n\nWe'll first supplement the rendering in `server.js` to parse incoming requests\noffsets:\n\n``` js\nvar sock = shoe(function (stream) {\n    sf.follow(-1,0).pipe(stream);\n    stream.pipe(split()).pipe(through(function (line) {\n        var offsets = JSON.parse(line);\n        sf.sliceReverse(offsets[0], offsets[1]).pipe(stream);\n    }));\n});\n```\n\nNow when the browser sends us a json array `[i,j]`, we'll send back the reversed\nslice from `data.txt` at those indices.\n\nHowever, now results arrive both from realtime updates and from requested\noffsets on the same websocket stream so we'll need to add some additional data\nto our data and rendering logic in `render.js`.\n\nAdd a `<div class=\"time\"></div>` to `row.html` then set that element to\n`row.time`:\n\n``` js\nmodule.exports = function () {\n    return hyperspace(html, function (row) {\n        return {\n            '.time': row.time,\n            '.who': row.who,\n            '.message': row.message\n        };\n    });\n};\n```\n\nNow we can add a more button to the `index.html` and bind a click handler in the\n`browser.js` to request more rows given the `count` of rows we've already\nobserved. The comparison function passed to `.sortTo()` will make sure that all\nthe results end up in the proper order no matter if they arrived from a realtime\nupdate or a requested slice:\n\n```\nvar shoe = require('shoe');\nvar render = require('./render')();\n\nvar count = 0;\nrender.on('element', function (elem) { count ++ });\n\nvar more = document.querySelector('#more');\nmore.addEventListener('click', function (ev) {\n    stream.write(JSON.stringify([ -count-3, -count ]) + '\\n');\n});\n\nvar stream = shoe('/sock');\nstream.pipe(render.sortTo('#rows', cmp));\n\nfunction cmp (a, b) {\n    var at = Number(a.querySelector('.time').textContent);\n    var bt = Number(b.querySelector('.time').textContent);\n    return bt - at;\n}\n```\n\nAnd now we have an seo-friendly, indexable feed with realtime updates and a\n\"more\" button to load more content!\n\n## no more\n\nFor a simple extension to the previous example, we can remove the \"more\" button\nonce the end of the feed is reached by sending a `false` row in the result set\nto specify a \"no more\" boundary.\n\nIn the server.js we can just pipe through an intermediary stream:\n\n``` js\nvar shoe = require('shoe');\nvar sock = shoe(function (stream) {\n    sf.follow(-1,0).pipe(stream);\n    stream.pipe(split()).pipe(through(function (line) {\n        var offsets = JSON.parse(line);\n        sf.sliceReverse(offsets[0], offsets[1])\n            .pipe(insertBoundary(offsets[0], offsets[1]))\n            .pipe(stream)\n        ;\n    }));\n});\nsock.install(server, '/sock');\n\nfunction insertBoundary (i, j) {\n    // add a `false` to the result stream when there are no more records\n    var count = 0;\n    return through(write, end);\n    function write (line) { count ++; this.queue(line) }\n    function end () {\n        if (count < j - i) this.queue('false\\n');\n    }\n}\n```\n\nthen our `render.js` can emit a `'no-more'` event when it finds a falsy row:\n\n``` js\nmodule.exports = function () {\n    return hyperspace(html, function (row) {\n        if (!row) {\n            this.emit('no-more');\n            return undefined;\n        }\n        return {\n            '.time': row.time,\n            '.who': row.who,\n            '.message': row.message\n        };\n    });\n};\n```\n\nand we can listen for the `'no-more'` event in `browser.js`:\n\n```\nrender.on('no-more', function () {\n    more.parentNode.removeChild(more);\n});\n```\n\nwhich removes the `more` button from the page when the end of the feed is\nreached.\n\nThe complete code for this demo is in `example/more`.\n\n# methods\n\n```\nvar hyperstream = require('hyperstream')\n```\n\n# var render = hyperstream(html, f)\n\nReturn a new `render` through stream that takes json strings or objects as input\nand outputs a stream of html strings after applying the transformations from\n`f(row)`.\n\n`f(row)` gets an object from the data source as input and should return an\nobject of [hyperglue](https://github.com/substack/hyperglue) css selectors\nmapped to content and attributes or a falsy value if nothing should be rendered\nfor the given `row`.\n\n# browser methods\n\nThese methods only apply browser-side because they deal with how to handle the\nrealtime update stream.\n\n## render.appendTo(target)\n\nAppend the html elements created from the hyperstream transform function\n`f(row)` directly to `target`.\n\n`target` can be an html element or a css selector.\n\n## render.prependTo(target)\n\nPrepend the html elements created from the hyperstream transform function\n`f(row)` directly to `target`.\n\n`target` can be an html element or a css selector.\n\n## render.sortTo(target, cmp)\n\nInsert the html elements created from the hyperstream transform function\n`f(row)` to `target` using the sorting function `cmp(a, b)` for each html\nelement `a` and `b` to be sorted.\n\n`target` can be an html element or a css selector.\n\n# browser events\n\n## render.on('element', function (elem) {})\n\nThis event fires for all elements created by the result stream, including those\nelements created server-side so long as `.prependTo()` or `.appendTo()` as been\ncalled on the same container that the server populated content with.\n\n# install\n\nWith [npm](https://npmjs.org) do:\n\n```\nnpm install hyperstream\n```\n\n# license\n\nMIT\n",
  "readmeFilename": "readme.markdown",
  "_id": "hyperspace@0.1.1",
  "_from": "hyperspace@~0.1.1"
}
